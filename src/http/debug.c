#include "./debug.h"
#include "utils/string_builder.h"
#include "utils/utils.h"

// returning a stringbuilder, that makes a string from the http_request, this is useful for
// debugging
StringBuilder* http_request_to_string_builder(const HttpRequest request, bool https) {

	StringBuilder* result = string_builder_init();

	const char* method = get_http_method_string(request.head.request_line.method);
	tstr request_uri = get_request_uri_as_string(request.head.request_line.uri);
	const char* protocol_version =
	    get_http_protocol_version_string(request.head.request_line.protocol_data.version);

	string_builder_append_single(result, "HttpRequest:\n");

	string_builder_append_single(result, "\tMethod:");
	string_builder_append_single(result, method);
	string_builder_append_single(result, "\n");

	STRING_BUILDER_APPENDF(result, return NULL;, "\tRequestURI: %s\n", tstr_cstr(&request_uri));
	tstr_free(&request_uri);

	string_builder_append_single(result, "\tProtocolVersion:");
	string_builder_append_single(result, protocol_version);
	string_builder_append_single(result, "\n");

	STRING_BUILDER_APPENDF(result, return NULL;, "\tSecure : %s\n", https ? "true" : " false");

	for(size_t i = 0; i < TVEC_LENGTH(HttpHeaderField, request.head.header_fields); ++i) {
		HttpHeaderField entry = TVEC_AT(HttpHeaderField, request.head.header_fields, i);

		STRING_BUILDER_APPENDF(result, return NULL;, "\tHeader:\n\t\tKey: %s \n\t\tValue: %s\n",
		                                           tstr_cstr(&entry.key), tstr_cstr(&entry.value));
	}
	STRING_BUILDER_APPENDF(result, return NULL;
	                       , "\tBody: %.*s\n", (int)request.body.size, (char*)request.body.data);
	return result;
}

NODISCARD StringBuilder*
html_from_string(StringBuilder* head_content, // NOLINT(bugprone-easily-swappable-parameters)
                 StringBuilder* script_content, StringBuilder* style_content,
                 StringBuilder* body_content) {

	StringBuilder* result = string_builder_init();

	string_builder_append_single(result, "<!DOCTYPE html><html>");
	string_builder_append_single(result, "<head>");
	string_builder_append_single(result,
	                             "<link rel=\"icon\" href=\"data:image/png;base64,iVBORw0KGgo=\">");
	string_builder_append_single(result, "<meta charset=\"UTF-8\">");
	string_builder_append_single(
	    result, "<meta name=\"description\" content=\"HTML generated by simple C Http Server\">");
	string_builder_append_single(result, "<meta name=\"author\" content=\"Totto16\">");
	string_builder_append_single(result, "<title>Page by Simple C Http Server</title>");
	if(head_content != NULL) {
		string_builder_append_string_builder(result, &head_content);
	}
	if(script_content != NULL) {
		string_builder_append_single(result, "<script type=\"text/javascript\">");

		string_builder_append_string_builder(result, &script_content);
		string_builder_append_single(result, "</script>");
		string_builder_append_single(
		    result,
		    "<noscript> Diese Seite Ben√∂tigt Javascript um zu funktionieren :( </noscript>");
	}
	if(style_content != NULL) {
		string_builder_append_single(result, "<style type=\"text/css\">");
		string_builder_append_string_builder(result, &style_content);
		string_builder_append_single(result, "</style>");
	}
	string_builder_append_single(result, "</head>");
	string_builder_append_single(result, "<body>");
	if(body_content != NULL) {
		string_builder_append_string_builder(result, &body_content);
	}
	string_builder_append_single(result, "</body>");
	string_builder_append_single(result, "</html>");

	return result;
}

StringBuilder* http_request_to_json(const HttpRequest request, bool https,
                                    SendSettings send_settings) {

	StringBuilder* body = string_builder_init();

	const char* method = get_http_method_string(request.head.request_line.method);
	const char* protocol_version =
	    get_http_protocol_version_string(request.head.request_line.protocol_data.version);

	string_builder_append_single(body, "{\"request\":\"");
	string_builder_append_single(body, method);
	string_builder_append_single(body, "\",");

	string_builder_append_single(body, "\"request_uri\": {");

	{

		const ParsedRequestURI request_uri = request.head.request_line.uri;

		// TODO(Totto): factor out some things, like e.g. NULL means not present, port == 0 means
		// default etc
		switch(request_uri.type) {
			case ParsedURITypeAsterisk: {
				string_builder_append_single(body, "\"type\": \"asterisk\"");
				break;
			}
			case ParsedURITypeAbsoluteURI: {
				const ParsedURI uri = request_uri.data.uri;
				const ParsedAuthority authority = uri.authority;

				tstr path_str = get_parsed_url_as_string(uri.path);
				tstr uri_str = get_uri_as_string(uri);

				STRING_BUILDER_APPENDF(body, return NULL;
				                       ,
				                       "\"type\": \"uri\", \"data\": { \"path\": { \"str_form\": "
				                       "\"%s\"  } , \"uri_str\":\"%s\"  , \"scheme\":\"%s\" , "
				                       "\"authority\": { \"user\": { \"name\": "
				                       "\"%s\",\"password\": \"%s\" }, \"host\": "
				                       "\"%s\", \"port\": "
				                       "\"%u\"  }}",
				                       tstr_cstr(&path_str), tstr_cstr(&uri_str),
				                       tstr_cstr(&uri.scheme),
				                       tstr_cstr(&authority.user_info.username),
				                       tstr_cstr(&authority.user_info.password),
				                       tstr_cstr(&authority.host), authority.port);

				tstr_free(&path_str);
				tstr_free(&uri_str);
				break;
			}
			case ParsedURITypeAbsPath: {
				tstr path_str = get_parsed_url_as_string(request_uri.data.path);

				STRING_BUILDER_APPENDF(body, return NULL;
				                       , "\"type\": \"path\", \"data\": { \"str_form\": \"%s\"  }",
				                       tstr_cstr(&path_str));

				tstr_free(&path_str);
				break;
			}
			case ParsedURITypeAuthority: {
				const ParsedAuthority authority = request_uri.data.authority;

				STRING_BUILDER_APPENDF(body, return NULL;
				                       ,
				                       "\"type\": \"authority\", \"data\": { \"user\": { \"name\": "
				                       "\"%s\",\"password\": \"%s\" }, \"host\": "
				                       "\"%s\", \"port\": "
				                       "\"%u\"  }",
				                       tstr_cstr(&authority.user_info.username),
				                       tstr_cstr(&authority.user_info.password),
				                       tstr_cstr(&authority.host), authority.port);
				break;
			}
			default: {
				return NULL;
			}
		}
	}

	string_builder_append_single(body, "}, \"protocol_version\":\"");
	string_builder_append_single(body, protocol_version);
	string_builder_append_single(body, "\",");

	STRING_BUILDER_APPENDF(body, return NULL;, "\"secure\":%s,", https ? "true" : "false");
	string_builder_append_single(body, "\"headers\":[");

	const size_t header_amount = TVEC_LENGTH(HttpHeaderField, request.head.header_fields);

	for(size_t i = 0; i < header_amount; ++i) {

		HttpHeaderField entry = TVEC_AT(HttpHeaderField, request.head.header_fields, i);

		STRING_BUILDER_APPENDF(body, return NULL;, "{\"header\":\"%s\", \"key\":\"%s\"}",
		                                         tstr_cstr(&entry.key), tstr_cstr(&entry.value));
		if(i + 1 < header_amount) {
			string_builder_append_single(body, ", ");
		} else {
			string_builder_append_single(body, "],");
		}
	}
	STRING_BUILDER_APPENDF(body, return NULL;
	                       , "\"body\":\"%.*s\"", (int)request.body.size, (char*)request.body.data);

	string_builder_append_single(body, ", \"settings\": {");

	STRING_BUILDER_APPENDF(
	    body, return NULL;
	    , "\"send_settings\":{\"compression\" : \"%s\", \"http_protocol\": \"%s\"} }",
	    get_string_for_compress_format(send_settings.compression_to_use),
	    get_http_protocol_version_string(send_settings.protocol_data.version));

	string_builder_append_single(body, "}");
	return body;
}

StringBuilder* http_request_to_html(const HttpRequest request, bool https,
                                    SendSettings send_settings) {

	StringBuilder* body = string_builder_init();

	const char* method = get_http_method_string(request.head.request_line.method);
	tstr request_uri = get_request_uri_as_string(request.head.request_line.uri);
	const char* protocol_version =
	    get_http_protocol_version_string(request.head.request_line.protocol_data.version);

	string_builder_append_single(body, "<h1 id=\"title\">HttpRequest:</h1><br>");

	string_builder_append_single(body, "<div id=\"request\"><div>Method:");
	string_builder_append_single(body, method);
	string_builder_append_single(body, "</div>");

	STRING_BUILDER_APPENDF(body, return NULL;
	                       , "<div>RequestURI: %s</div>", tstr_cstr(&request_uri));
	tstr_free(&request_uri);

	string_builder_append_single(body, "<div>ProtocolVersion:");
	string_builder_append_single(body, protocol_version);
	string_builder_append_single(body, "</div>");
	STRING_BUILDER_APPENDF(
	    body, return NULL;,
	                      "<div>Secure : %s</div><button id=\"shutdown\"> Shutdown </button></div>",
	                      https ? "true" : "false");
	string_builder_append_single(body, "<div id=\"header\">");
	for(size_t i = 0; i < TVEC_LENGTH(HttpHeaderField, request.head.header_fields); ++i) {

		HttpHeaderField entry = TVEC_AT(HttpHeaderField, request.head.header_fields, i);

		STRING_BUILDER_APPENDF(
		    body, return NULL;
		    , "<div><h2>Header:</h2><br><h3>Key:</h3> %s<br><h3>Value:</h3> %s</div>",
		    tstr_cstr(&entry.key), tstr_cstr(&entry.value));
	}

	string_builder_append_single(body, "</div> <div id=\"settings\">");
	string_builder_append_single(body, "<h1>Settings:</h1> <br>");
	{
		string_builder_append_single(body, "</div> <div id=\"send_settings\">");
		string_builder_append_single(body, "<h2>Send Settings:</h2> <br>");
		STRING_BUILDER_APPENDF(body, return NULL;
		                       , "<h3>Compression:</h3> %s",
		                       get_string_for_compress_format(send_settings.compression_to_use));
		STRING_BUILDER_APPENDF(body, return NULL;, "<h3>HTTP Protocol:</h3> %s",
		                                         get_http_protocol_version_string(
		                                             send_settings.protocol_data.version));
		string_builder_append_single(body, "</div>");
	}
	string_builder_append_single(body, "</div>");

	string_builder_append_single(body, "</div> <div id=\"body\">");
	STRING_BUILDER_APPENDF(body, return NULL;, "<h1>Body:</h1> <br>%.*s", (int)request.body.size,
	                                         (char*)request.body.data);
	string_builder_append_single(body, "</div>");

	// style

	StringBuilder* style = string_builder_init();
	string_builder_append_single(
	    style, "body{background: linear-gradient( 90deg, rgb(255, 0, 0) 0%, rgb(255, 154, 0) 10%, "
	           "rgb(208, 222, 33) 20%, rgb(79, 220, 74) 30%, rgb(63, 218, 216) 40%, rgb(47, 201, "
	           "226) 50%, rgb(28, 127, 238) 60%, rgb(95, 21, 242) 70%, rgb(186, 12, 248) 80%, "
	           "rgb(251, 7, 217) 90%, rgb(255, 0, 0) 100% );}"
	           "#request {display: flex;justify-content: center;gap: 5%;color: #1400ff;text-align: "
	           "center;align-items: center;}"
	           "#header {display:flex; flex-direction: column;align-items: center;overflow-wrap: "
	           "anywhere;text-align: center;word-wrap: anywhere;}"
	           "#body {padding: 1%;text-align: center;border: solid 4px black;margin: 1%;}"
	           "#shutdown {border: none;cursor: crosshair;opacity: .9;padding: 16px "
	           "20px;background-color: #c7ff00;font-weight: 900;color: #000;}"
	           "#title{text-align: center;}"
	           "#settings {display:flex; flex-direction: column;align-items: center;overflow-wrap: "
	           "anywhere;text-align: center;word-wrap: anywhere;}"
	           "#send_settings {display:flex; flex-direction: column;align-items: "
	           "center;overflow-wrap: "
	           "anywhere;text-align: center;word-wrap: anywhere;}"

	);

	// script
	StringBuilder* script = string_builder_init();
	string_builder_append_single(
	    script, "function requestShutdown(){"
	            "	document.querySelector('button').onclick = ()=>{"
	            "		let shutdownUrl = `${location.protocol}//${location.host}/shutdown`;"
	            "		const xhr = new XMLHttpRequest();"
	            "		xhr.onload = (response)=>{"
	            "			if(xhr.status == 200){"
	            "				alert(\"Successfully Shut Down the server!\");"
	            "			}else{"
	            "				console.error(xhr);"
	            "				alert(\"Couldn't Shut Down the Server!\");"
	            "			}"
	            "		};"
	            "		xhr.onerror = (err)=>{"
	            "			console.error(err);"
	            "			alert(\"Couldn't Shut Down the Server!\");"
	            "		};"
	            "		xhr.open(\"GET\", shutdownUrl);"
	            "		xhr.send();"
	            "	}"
	            "}"
	            "window.addEventListener('DOMContentLoaded',requestShutdown);");

	StringBuilder* html_result = html_from_string(NULL, script, style, body);
	return html_result;
}
