

// huffman codes from: https://datatracker.ietf.org/doc/html/rfc7541#appendix-B
//                                                      code
//                           code as bits                 as hex   len
//         sym              aligned to MSB                aligned   in
//                                                        to LSB   bits
//        (  0)  |11111111|11000                             1ff8  [13]
//        (  1)  |11111111|11111111|1011000                7fffd8  [23]
//        (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]
//        (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]
//        (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]
//        (  5)  |11111111|11111111|11111110|0101         fffffe5  [28]
//        (  6)  |11111111|11111111|11111110|0110         fffffe6  [28]
//        (  7)  |11111111|11111111|11111110|0111         fffffe7  [28]
//        (  8)  |11111111|11111111|11111110|1000         fffffe8  [28]
//        (  9)  |11111111|11111111|11101010               ffffea  [24]
//        ( 10)  |11111111|11111111|11111111|111100      3ffffffc  [30]
//        ( 11)  |11111111|11111111|11111110|1001         fffffe9  [28]
//        ( 12)  |11111111|11111111|11111110|1010         fffffea  [28]
//        ( 13)  |11111111|11111111|11111111|111101      3ffffffd  [30]
//        ( 14)  |11111111|11111111|11111110|1011         fffffeb  [28]
//        ( 15)  |11111111|11111111|11111110|1100         fffffec  [28]
//        ( 16)  |11111111|11111111|11111110|1101         fffffed  [28]
//        ( 17)  |11111111|11111111|11111110|1110         fffffee  [28]
//        ( 18)  |11111111|11111111|11111110|1111         fffffef  [28]
//        ( 19)  |11111111|11111111|11111111|0000         ffffff0  [28]
//        ( 20)  |11111111|11111111|11111111|0001         ffffff1  [28]
//        ( 21)  |11111111|11111111|11111111|0010         ffffff2  [28]
//        ( 22)  |11111111|11111111|11111111|111110      3ffffffe  [30]
//        ( 23)  |11111111|11111111|11111111|0011         ffffff3  [28]
//        ( 24)  |11111111|11111111|11111111|0100         ffffff4  [28]
//        ( 25)  |11111111|11111111|11111111|0101         ffffff5  [28]
//        ( 26)  |11111111|11111111|11111111|0110         ffffff6  [28]
//        ( 27)  |11111111|11111111|11111111|0111         ffffff7  [28]
//        ( 28)  |11111111|11111111|11111111|1000         ffffff8  [28]
//        ( 29)  |11111111|11111111|11111111|1001         ffffff9  [28]
//        ( 30)  |11111111|11111111|11111111|1010         ffffffa  [28]
//        ( 31)  |11111111|11111111|11111111|1011         ffffffb  [28]
//    ' ' ( 32)  |010100                                       14  [ 6]
//    '!' ( 33)  |11111110|00                                 3f8  [10]
//    '"' ( 34)  |11111110|01                                 3f9  [10]
//    '#' ( 35)  |11111111|1010                               ffa  [12]
//    '$' ( 36)  |11111111|11001                             1ff9  [13]
//    '%' ( 37)  |010101                                       15  [ 6]
//    '&' ( 38)  |11111000                                     f8  [ 8]
//    ''' ( 39)  |11111111|010                                7fa  [11]
//    '(' ( 40)  |11111110|10                                 3fa  [10]
//    ')' ( 41)  |11111110|11                                 3fb  [10]
//    '*' ( 42)  |11111001                                     f9  [ 8]
//    '+' ( 43)  |11111111|011                                7fb  [11]
//    ',' ( 44)  |11111010                                     fa  [ 8]
//    '-' ( 45)  |010110                                       16  [ 6]
//    '.' ( 46)  |010111                                       17  [ 6]
//    '/' ( 47)  |011000                                       18  [ 6]
//    '0' ( 48)  |00000                                         0  [ 5]
//    '1' ( 49)  |00001                                         1  [ 5]
//    '2' ( 50)  |00010                                         2  [ 5]
//    '3' ( 51)  |011001                                       19  [ 6]
//    '4' ( 52)  |011010                                       1a  [ 6]
//    '5' ( 53)  |011011                                       1b  [ 6]
//    '6' ( 54)  |011100                                       1c  [ 6]
//    '7' ( 55)  |011101                                       1d  [ 6]
//    '8' ( 56)  |011110                                       1e  [ 6]
//    '9' ( 57)  |011111                                       1f  [ 6]
//    ':' ( 58)  |1011100                                      5c  [ 7]
//    ';' ( 59)  |11111011                                     fb  [ 8]
//    '<' ( 60)  |11111111|1111100                           7ffc  [15]
//    '=' ( 61)  |100000                                       20  [ 6]
//    '>' ( 62)  |11111111|1011                               ffb  [12]
//    '?' ( 63)  |11111111|00                                 3fc  [10]
//    '@' ( 64)  |11111111|11010                             1ffa  [13]
//    'A' ( 65)  |100001                                       21  [ 6]
//    'B' ( 66)  |1011101                                      5d  [ 7]
//    'C' ( 67)  |1011110                                      5e  [ 7]
//    'D' ( 68)  |1011111                                      5f  [ 7]
//    'E' ( 69)  |1100000                                      60  [ 7]
//    'F' ( 70)  |1100001                                      61  [ 7]
//    'G' ( 71)  |1100010                                      62  [ 7]
//    'H' ( 72)  |1100011                                      63  [ 7]
//    'I' ( 73)  |1100100                                      64  [ 7]
//    'J' ( 74)  |1100101                                      65  [ 7]
//    'K' ( 75)  |1100110                                      66  [ 7]
//    'L' ( 76)  |1100111                                      67  [ 7]
//    'M' ( 77)  |1101000                                      68  [ 7]
//    'N' ( 78)  |1101001                                      69  [ 7]
//    'O' ( 79)  |1101010                                      6a  [ 7]
//    'P' ( 80)  |1101011                                      6b  [ 7]
//    'Q' ( 81)  |1101100                                      6c  [ 7]
//    'R' ( 82)  |1101101                                      6d  [ 7]
//    'S' ( 83)  |1101110                                      6e  [ 7]
//    'T' ( 84)  |1101111                                      6f  [ 7]
//    'U' ( 85)  |1110000                                      70  [ 7]
//    'V' ( 86)  |1110001                                      71  [ 7]
//    'W' ( 87)  |1110010                                      72  [ 7]
//    'X' ( 88)  |11111100                                     fc  [ 8]
//    'Y' ( 89)  |1110011                                      73  [ 7]
//    'Z' ( 90)  |11111101                                     fd  [ 8]
//    '[' ( 91)  |11111111|11011                             1ffb  [13]
//    '\' ( 92)  |11111111|11111110|000                     7fff0  [19]
//    ']' ( 93)  |11111111|11100                             1ffc  [13]
//    '^' ( 94)  |11111111|111100                            3ffc  [14]
//    '_' ( 95)  |100010                                       22  [ 6]
//    '`' ( 96)  |11111111|1111101                           7ffd  [15]
//    'a' ( 97)  |00011                                         3  [ 5]
//    'b' ( 98)  |100011                                       23  [ 6]
//    'c' ( 99)  |00100                                         4  [ 5]
//    'd' (100)  |100100                                       24  [ 6]
//    'e' (101)  |00101                                         5  [ 5]
//    'f' (102)  |100101                                       25  [ 6]
//    'g' (103)  |100110                                       26  [ 6]
//    'h' (104)  |100111                                       27  [ 6]
//    'i' (105)  |00110                                         6  [ 5]
//    'j' (106)  |1110100                                      74  [ 7]
//    'k' (107)  |1110101                                      75  [ 7]
//    'l' (108)  |101000                                       28  [ 6]
//    'm' (109)  |101001                                       29  [ 6]
//    'n' (110)  |101010                                       2a  [ 6]
//    'o' (111)  |00111                                         7  [ 5]
//    'p' (112)  |101011                                       2b  [ 6]
//    'q' (113)  |1110110                                      76  [ 7]
//    'r' (114)  |101100                                       2c  [ 6]
//    's' (115)  |01000                                         8  [ 5]
//    't' (116)  |01001                                         9  [ 5]
//    'u' (117)  |101101                                       2d  [ 6]
//    'v' (118)  |1110111                                      77  [ 7]
//    'w' (119)  |1111000                                      78  [ 7]
//    'x' (120)  |1111001                                      79  [ 7]
//    'y' (121)  |1111010                                      7a  [ 7]
//    'z' (122)  |1111011                                      7b  [ 7]
//    '{' (123)  |11111111|1111110                           7ffe  [15]
//    '|' (124)  |11111111|100                                7fc  [11]
//    '}' (125)  |11111111|111101                            3ffd  [14]
//    '~' (126)  |11111111|11101                             1ffd  [13]
//        (127)  |11111111|11111111|11111111|1100         ffffffc  [28]
//        (128)  |11111111|11111110|0110                    fffe6  [20]
//        (129)  |11111111|11111111|010010                 3fffd2  [22]
//        (130)  |11111111|11111110|0111                    fffe7  [20]
//        (131)  |11111111|11111110|1000                    fffe8  [20]
//        (132)  |11111111|11111111|010011                 3fffd3  [22]
//        (133)  |11111111|11111111|010100                 3fffd4  [22]
//        (134)  |11111111|11111111|010101                 3fffd5  [22]
//        (135)  |11111111|11111111|1011001                7fffd9  [23]
//        (136)  |11111111|11111111|010110                 3fffd6  [22]
//        (137)  |11111111|11111111|1011010                7fffda  [23]
//        (138)  |11111111|11111111|1011011                7fffdb  [23]
//        (139)  |11111111|11111111|1011100                7fffdc  [23]
//        (140)  |11111111|11111111|1011101                7fffdd  [23]
//        (141)  |11111111|11111111|1011110                7fffde  [23]
//        (142)  |11111111|11111111|11101011               ffffeb  [24]
//        (143)  |11111111|11111111|1011111                7fffdf  [23]
//        (144)  |11111111|11111111|11101100               ffffec  [24]
//        (145)  |11111111|11111111|11101101               ffffed  [24]
//        (146)  |11111111|11111111|010111                 3fffd7  [22]
//        (147)  |11111111|11111111|1100000                7fffe0  [23]
//        (148)  |11111111|11111111|11101110               ffffee  [24]
//        (149)  |11111111|11111111|1100001                7fffe1  [23]
//        (150)  |11111111|11111111|1100010                7fffe2  [23]
//        (151)  |11111111|11111111|1100011                7fffe3  [23]
//        (152)  |11111111|11111111|1100100                7fffe4  [23]
//        (153)  |11111111|11111110|11100                  1fffdc  [21]
//        (154)  |11111111|11111111|011000                 3fffd8  [22]
//        (155)  |11111111|11111111|1100101                7fffe5  [23]   (145)  |11111111|11111111|11101101               ffffed  [24]
//        (146)  |11111111|11111111|010111                 3fffd7  [22]
//        (147)  |11111111|11111111|1100000                7fffe0  [23]
//        (156)  |11111111|11111111|011001                 3fffd9  [22]
//        (157)  |11111111|11111111|1100110                7fffe6  [23]
//        (158)  |11111111|11111111|1100111                7fffe7  [23]
//        (159)  |11111111|11111111|11101111               ffffef  [24]
//        (160)  |11111111|11111111|011010                 3fffda  [22]
//        (161)  |11111111|11111110|11101                  1fffdd  [21]
//        (162)  |11111111|11111110|1001                    fffe9  [20]
//        (163)  |11111111|11111111|011011                 3fffdb  [22]
//        (164)  |11111111|11111111|011100                 3fffdc  [22]
//        (165)  |11111111|11111111|1101000                7fffe8  [23]
//        (166)  |11111111|11111111|1101001                7fffe9  [23]
//        (167)  |11111111|11111110|11110                  1fffde  [21]
//        (168)  |11111111|11111111|1101010                7fffea  [23]
//        (169)  |11111111|11111111|011101                 3fffdd  [22]
//        (170)  |11111111|11111111|011110                 3fffde  [22]
//        (171)  |11111111|11111111|11110000               fffff0  [24]
//        (172)  |11111111|11111110|11111                  1fffdf  [21]
//        (173)  |11111111|11111111|011111                 3fffdf  [22]
//        (174)  |11111111|11111111|1101011                7fffeb  [23]
//        (175)  |11111111|11111111|1101100                7fffec  [23]
//        (176)  |11111111|11111111|00000                  1fffe0  [21]
//        (177)  |11111111|11111111|00001                  1fffe1  [21]
//        (178)  |11111111|11111111|100000                 3fffe0  [22]
//        (179)  |11111111|11111111|00010                  1fffe2  [21]
//        (180)  |11111111|11111111|1101101                7fffed  [23]
//        (181)  |11111111|11111111|100001                 3fffe1  [22]
//        (182)  |11111111|11111111|1101110                7fffee  [23]
//        (183)  |11111111|11111111|1101111                7fffef  [23]
//        (184)  |11111111|11111110|1010                    fffea  [20]
//        (185)  |11111111|11111111|100010                 3fffe2  [22]
//        (186)  |11111111|11111111|100011                 3fffe3  [22]
//        (187)  |11111111|11111111|100100                 3fffe4  [22]
//        (188)  |11111111|11111111|1110000                7ffff0  [23]
//        (189)  |11111111|11111111|100101                 3fffe5  [22]
//        (190)  |11111111|11111111|100110                 3fffe6  [22]
//        (191)  |11111111|11111111|1110001                7ffff1  [23]
//        (192)  |11111111|11111111|11111000|00           3ffffe0  [26]
//        (193)  |11111111|11111111|11111000|01           3ffffe1  [26]
//        (194)  |11111111|11111110|1011                    fffeb  [20]
//        (195)  |11111111|11111110|001                     7fff1  [19]
//        (196)  |11111111|11111111|100111                 3fffe7  [22]
//        (197)  |11111111|11111111|1110010                7ffff2  [23]
//        (198)  |11111111|11111111|101000                 3fffe8  [22]
//        (199)  |11111111|11111111|11110110|0            1ffffec  [25]
//        (200)  |11111111|11111111|11111000|10           3ffffe2  [26]
//        (201)  |11111111|11111111|11111000|11           3ffffe3  [26]
//        (202)  |11111111|11111111|11111001|00           3ffffe4  [26]
//        (203)  |11111111|11111111|11111011|110          7ffffde  [27]
//        (204)  |11111111|11111111|11111011|111          7ffffdf  [27]
//        (205)  |11111111|11111111|11111001|01           3ffffe5  [26]
//        (206)  |11111111|11111111|11110001               fffff1  [24]
//        (207)  |11111111|11111111|11110110|1            1ffffed  [25]
//        (208)  |11111111|11111110|010                     7fff2  [19]
//        (209)  |11111111|11111111|00011                  1fffe3  [21]
//        (210)  |11111111|11111111|11111001|10           3ffffe6  [26]
//        (211)  |11111111|11111111|11111100|000          7ffffe0  [27]
//        (212)  |11111111|11111111|11111100|001          7ffffe1  [27]
//        (213)  |11111111|11111111|11111001|11           3ffffe7  [26]
//        (214)  |11111111|11111111|11111100|010          7ffffe2  [27]
//        (215)  |11111111|11111111|11110010               fffff2  [24]
//        (216)  |11111111|11111111|00100                  1fffe4  [21]
//        (217)  |11111111|11111111|00101                  1fffe5  [21]
//        (218)  |11111111|11111111|11111010|00           3ffffe8  [26]
//        (219)  |11111111|11111111|11111010|01           3ffffe9  [26]
//        (220)  |11111111|11111111|11111111|1101         ffffffd  [28]
//        (221)  |11111111|11111111|11111100|011          7ffffe3  [27]
//        (222)  |11111111|11111111|11111100|100          7ffffe4  [27]
//        (223)  |11111111|11111111|11111100|101          7ffffe5  [27]
//        (224)  |11111111|11111110|1100                    fffec  [20]
//        (225)  |11111111|11111111|11110011               fffff3  [24]
//        (226)  |11111111|11111110|1101                    fffed  [20]
//        (227)  |11111111|11111111|00110                  1fffe6  [21]
//        (228)  |11111111|11111111|101001                 3fffe9  [22]
//        (229)  |11111111|11111111|00111                  1fffe7  [21]
//        (230)  |11111111|11111111|01000                  1fffe8  [21]
//        (231)  |11111111|11111111|1110011                7ffff3  [23]
//        (232)  |11111111|11111111|101010                 3fffea  [22]
//        (233)  |11111111|11111111|101011                 3fffeb  [22]
//        (234)  |11111111|11111111|11110111|0            1ffffee  [25]
//        (235)  |11111111|11111111|11110111|1            1ffffef  [25]
//        (236)  |11111111|11111111|11110100               fffff4  [24]
//        (237)  |11111111|11111111|11110101               fffff5  [24]
//        (238)  |11111111|11111111|11111010|10           3ffffea  [26]
//        (239)  |11111111|11111111|1110100                7ffff4  [23]
//        (240)  |11111111|11111111|11111010|11           3ffffeb  [26]
//        (241)  |11111111|11111111|11111100|110          7ffffe6  [27]
//        (242)  |11111111|11111111|11111011|00           3ffffec  [26]
//        (243)  |11111111|11111111|11111011|01           3ffffed  [26]
//        (244)  |11111111|11111111|11111100|111          7ffffe7  [27]
//        (245)  |11111111|11111111|11111101|000          7ffffe8  [27]
//        (246)  |11111111|11111111|11111101|001          7ffffe9  [27]
//        (247)  |11111111|11111111|11111101|010          7ffffea  [27]
//        (248)  |11111111|11111111|11111101|011          7ffffeb  [27]
//        (249)  |11111111|11111111|11111111|1110         ffffffe  [28]
//        (250)  |11111111|11111111|11111101|100          7ffffec  [27]
//        (251)  |11111111|11111111|11111101|101          7ffffed  [27]
//        (252)  |11111111|11111111|11111101|110          7ffffee  [27]
//        (253)  |11111111|11111111|11111101|111          7ffffef  [27]
//        (254)  |11111111|11111111|11111110|000          7fffff0  [27]
//        (255)  |11111111|11111111|11111011|10           3ffffee  [26]
//    EOS (256)  |11111111|11111111|11111111|111111      3fffffff  [30]

import fs from "node:fs"
import path from "node:path"

interface RawHuffmanCode {
    sym: number,
    bits: string,
    hex: string,
    bit_len: number
}

const raw_codes: RawHuffmanCode[] = [
    { "sym": 0, "bits": "11111111|11000", "hex": "1ff8", "bit_len": 13 },
    { "sym": 1, "bits": "11111111|11111111|1011000", "hex": "7fffd8", "bit_len": 23 },
    { "sym": 2, "bits": "11111111|11111111|11111110|0010", "hex": "fffffe2", "bit_len": 28 },
    { "sym": 3, "bits": "11111111|11111111|11111110|0011", "hex": "fffffe3", "bit_len": 28 },
    { "sym": 4, "bits": "11111111|11111111|11111110|0100", "hex": "fffffe4", "bit_len": 28 },
    { "sym": 5, "bits": "11111111|11111111|11111110|0101", "hex": "fffffe5", "bit_len": 28 },
    { "sym": 6, "bits": "11111111|11111111|11111110|0110", "hex": "fffffe6", "bit_len": 28 },
    { "sym": 7, "bits": "11111111|11111111|11111110|0111", "hex": "fffffe7", "bit_len": 28 },
    { "sym": 8, "bits": "11111111|11111111|11111110|1000", "hex": "fffffe8", "bit_len": 28 },
    { "sym": 9, "bits": "11111111|11111111|11101010", "hex": "ffffea", "bit_len": 24 },
    { "sym": 10, "bits": "11111111|11111111|11111111|111100", "hex": "3ffffffc", "bit_len": 30 },
    { "sym": 11, "bits": "11111111|11111111|11111110|1001", "hex": "fffffe9", "bit_len": 28 },
    { "sym": 12, "bits": "11111111|11111111|11111110|1010", "hex": "fffffea", "bit_len": 28 },
    { "sym": 13, "bits": "11111111|11111111|11111111|111101", "hex": "3ffffffd", "bit_len": 30 },
    { "sym": 14, "bits": "11111111|11111111|11111110|1011", "hex": "fffffeb", "bit_len": 28 },
    { "sym": 15, "bits": "11111111|11111111|11111110|1100", "hex": "fffffec", "bit_len": 28 },
    { "sym": 16, "bits": "11111111|11111111|11111110|1101", "hex": "fffffed", "bit_len": 28 },
    { "sym": 17, "bits": "11111111|11111111|11111110|1110", "hex": "fffffee", "bit_len": 28 },
    { "sym": 18, "bits": "11111111|11111111|11111110|1111", "hex": "fffffef", "bit_len": 28 },
    { "sym": 19, "bits": "11111111|11111111|11111111|0000", "hex": "ffffff0", "bit_len": 28 },
    { "sym": 20, "bits": "11111111|11111111|11111111|0001", "hex": "ffffff1", "bit_len": 28 },
    { "sym": 21, "bits": "11111111|11111111|11111111|0010", "hex": "ffffff2", "bit_len": 28 },
    { "sym": 22, "bits": "11111111|11111111|11111111|111110", "hex": "3ffffffe", "bit_len": 30 },
    { "sym": 23, "bits": "11111111|11111111|11111111|0011", "hex": "ffffff3", "bit_len": 28 },
    { "sym": 24, "bits": "11111111|11111111|11111111|0100", "hex": "ffffff4", "bit_len": 28 },
    { "sym": 25, "bits": "11111111|11111111|11111111|0101", "hex": "ffffff5", "bit_len": 28 },
    { "sym": 26, "bits": "11111111|11111111|11111111|0110", "hex": "ffffff6", "bit_len": 28 },
    { "sym": 27, "bits": "11111111|11111111|11111111|0111", "hex": "ffffff7", "bit_len": 28 },
    { "sym": 28, "bits": "11111111|11111111|11111111|1000", "hex": "ffffff8", "bit_len": 28 },
    { "sym": 29, "bits": "11111111|11111111|11111111|1001", "hex": "ffffff9", "bit_len": 28 },
    { "sym": 30, "bits": "11111111|11111111|11111111|1010", "hex": "ffffffa", "bit_len": 28 },
    { "sym": 31, "bits": "11111111|11111111|11111111|1011", "hex": "ffffffb", "bit_len": 28 },
    { "sym": 32, "bits": "010100", "hex": "14", "bit_len": 6 },
    { "sym": 33, "bits": "11111110|00", "hex": "3f8", "bit_len": 10 },
    { "sym": 34, "bits": "11111110|01", "hex": "3f9", "bit_len": 10 },
    { "sym": 35, "bits": "11111111|1010", "hex": "ffa", "bit_len": 12 },
    { "sym": 36, "bits": "11111111|11001", "hex": "1ff9", "bit_len": 13 },
    { "sym": 37, "bits": "010101", "hex": "15", "bit_len": 6 },
    { "sym": 38, "bits": "11111000", "hex": "f8", "bit_len": 8 },
    { "sym": 39, "bits": "11111111|010", "hex": "7fa", "bit_len": 11 },
    { "sym": 40, "bits": "11111110|10", "hex": "3fa", "bit_len": 10 },
    { "sym": 41, "bits": "11111110|11", "hex": "3fb", "bit_len": 10 },
    { "sym": 42, "bits": "11111001", "hex": "f9", "bit_len": 8 },
    { "sym": 43, "bits": "11111111|011", "hex": "7fb", "bit_len": 11 },
    { "sym": 44, "bits": "11111010", "hex": "fa", "bit_len": 8 },
    { "sym": 45, "bits": "010110", "hex": "16", "bit_len": 6 },
    { "sym": 46, "bits": "010111", "hex": "17", "bit_len": 6 },
    { "sym": 47, "bits": "011000", "hex": "18", "bit_len": 6 },
    { "sym": 48, "bits": "00000", "hex": "0", "bit_len": 5 },
    { "sym": 49, "bits": "00001", "hex": "1", "bit_len": 5 },
    { "sym": 50, "bits": "00010", "hex": "2", "bit_len": 5 },
    { "sym": 51, "bits": "011001", "hex": "19", "bit_len": 6 },
    { "sym": 52, "bits": "011010", "hex": "1a", "bit_len": 6 },
    { "sym": 53, "bits": "011011", "hex": "1b", "bit_len": 6 },
    { "sym": 54, "bits": "011100", "hex": "1c", "bit_len": 6 },
    { "sym": 55, "bits": "011101", "hex": "1d", "bit_len": 6 },
    { "sym": 56, "bits": "011110", "hex": "1e", "bit_len": 6 },
    { "sym": 57, "bits": "011111", "hex": "1f", "bit_len": 6 },
    { "sym": 58, "bits": "1011100", "hex": "5c", "bit_len": 7 },
    { "sym": 59, "bits": "11111011", "hex": "fb", "bit_len": 8 },
    { "sym": 60, "bits": "11111111|1111100", "hex": "7ffc", "bit_len": 15 },
    { "sym": 61, "bits": "100000", "hex": "20", "bit_len": 6 },
    { "sym": 62, "bits": "11111111|1011", "hex": "ffb", "bit_len": 12 },
    { "sym": 63, "bits": "11111111|00", "hex": "3fc", "bit_len": 10 },
    { "sym": 64, "bits": "11111111|11010", "hex": "1ffa", "bit_len": 13 },
    { "sym": 65, "bits": "100001", "hex": "21", "bit_len": 6 },
    { "sym": 66, "bits": "1011101", "hex": "5d", "bit_len": 7 },
    { "sym": 67, "bits": "1011110", "hex": "5e", "bit_len": 7 },
    { "sym": 68, "bits": "1011111", "hex": "5f", "bit_len": 7 },
    { "sym": 69, "bits": "1100000", "hex": "60", "bit_len": 7 },
    { "sym": 70, "bits": "1100001", "hex": "61", "bit_len": 7 },
    { "sym": 71, "bits": "1100010", "hex": "62", "bit_len": 7 },
    { "sym": 72, "bits": "1100011", "hex": "63", "bit_len": 7 },
    { "sym": 73, "bits": "1100100", "hex": "64", "bit_len": 7 },
    { "sym": 74, "bits": "1100101", "hex": "65", "bit_len": 7 },
    { "sym": 75, "bits": "1100110", "hex": "66", "bit_len": 7 },
    { "sym": 76, "bits": "1100111", "hex": "67", "bit_len": 7 },
    { "sym": 77, "bits": "1101000", "hex": "68", "bit_len": 7 },
    { "sym": 78, "bits": "1101001", "hex": "69", "bit_len": 7 },
    { "sym": 79, "bits": "1101010", "hex": "6a", "bit_len": 7 },
    { "sym": 80, "bits": "1101011", "hex": "6b", "bit_len": 7 },
    { "sym": 81, "bits": "1101100", "hex": "6c", "bit_len": 7 },
    { "sym": 82, "bits": "1101101", "hex": "6d", "bit_len": 7 },
    { "sym": 83, "bits": "1101110", "hex": "6e", "bit_len": 7 },
    { "sym": 84, "bits": "1101111", "hex": "6f", "bit_len": 7 },
    { "sym": 85, "bits": "1110000", "hex": "70", "bit_len": 7 },
    { "sym": 86, "bits": "1110001", "hex": "71", "bit_len": 7 },
    { "sym": 87, "bits": "1110010", "hex": "72", "bit_len": 7 },
    { "sym": 88, "bits": "11111100", "hex": "fc", "bit_len": 8 },
    { "sym": 89, "bits": "1110011", "hex": "73", "bit_len": 7 },
    { "sym": 90, "bits": "11111101", "hex": "fd", "bit_len": 8 },
    { "sym": 91, "bits": "11111111|11011", "hex": "1ffb", "bit_len": 13 },
    { "sym": 92, "bits": "11111111|11111110|000", "hex": "7fff0", "bit_len": 19 },
    { "sym": 93, "bits": "11111111|11100", "hex": "1ffc", "bit_len": 13 },
    { "sym": 94, "bits": "11111111|111100", "hex": "3ffc", "bit_len": 14 },
    { "sym": 95, "bits": "100010", "hex": "22", "bit_len": 6 },
    { "sym": 96, "bits": "11111111|1111101", "hex": "7ffd", "bit_len": 15 },
    { "sym": 97, "bits": "00011", "hex": "3", "bit_len": 5 },
    { "sym": 98, "bits": "100011", "hex": "23", "bit_len": 6 },
    { "sym": 99, "bits": "00100", "hex": "4", "bit_len": 5 },
    { "sym": 100, "bits": "100100", "hex": "24", "bit_len": 6 },
    { "sym": 101, "bits": "00101", "hex": "5", "bit_len": 5 },
    { "sym": 102, "bits": "100101", "hex": "25", "bit_len": 6 },
    { "sym": 103, "bits": "100110", "hex": "26", "bit_len": 6 },
    { "sym": 104, "bits": "100111", "hex": "27", "bit_len": 6 },
    { "sym": 105, "bits": "00110", "hex": "6", "bit_len": 5 },
    { "sym": 106, "bits": "1110100", "hex": "74", "bit_len": 7 },
    { "sym": 107, "bits": "1110101", "hex": "75", "bit_len": 7 },
    { "sym": 108, "bits": "101000", "hex": "28", "bit_len": 6 },
    { "sym": 109, "bits": "101001", "hex": "29", "bit_len": 6 },
    { "sym": 110, "bits": "101010", "hex": "2a", "bit_len": 6 },
    { "sym": 111, "bits": "00111", "hex": "7", "bit_len": 5 },
    { "sym": 112, "bits": "101011", "hex": "2b", "bit_len": 6 },
    { "sym": 113, "bits": "1110110", "hex": "76", "bit_len": 7 },
    { "sym": 114, "bits": "101100", "hex": "2c", "bit_len": 6 },
    { "sym": 115, "bits": "01000", "hex": "8", "bit_len": 5 },
    { "sym": 116, "bits": "01001", "hex": "9", "bit_len": 5 },
    { "sym": 117, "bits": "101101", "hex": "2d", "bit_len": 6 },
    { "sym": 118, "bits": "1110111", "hex": "77", "bit_len": 7 },
    { "sym": 119, "bits": "1111000", "hex": "78", "bit_len": 7 },
    { "sym": 120, "bits": "1111001", "hex": "79", "bit_len": 7 },
    { "sym": 121, "bits": "1111010", "hex": "7a", "bit_len": 7 },
    { "sym": 122, "bits": "1111011", "hex": "7b", "bit_len": 7 },
    { "sym": 123, "bits": "11111111|1111110", "hex": "7ffe", "bit_len": 15 },
    { "sym": 124, "bits": "11111111|100", "hex": "7fc", "bit_len": 11 },
    { "sym": 125, "bits": "11111111|111101", "hex": "3ffd", "bit_len": 14 },
    { "sym": 126, "bits": "11111111|11101", "hex": "1ffd", "bit_len": 13 },
    { "sym": 127, "bits": "11111111|11111111|11111111|1100", "hex": "ffffffc", "bit_len": 28 },
    { "sym": 128, "bits": "11111111|11111110|0110", "hex": "fffe6", "bit_len": 20 },
    { "sym": 129, "bits": "11111111|11111111|010010", "hex": "3fffd2", "bit_len": 22 },
    { "sym": 130, "bits": "11111111|11111110|0111", "hex": "fffe7", "bit_len": 20 },
    { "sym": 131, "bits": "11111111|11111110|1000", "hex": "fffe8", "bit_len": 20 },
    { "sym": 132, "bits": "11111111|11111111|010011", "hex": "3fffd3", "bit_len": 22 },
    { "sym": 133, "bits": "11111111|11111111|010100", "hex": "3fffd4", "bit_len": 22 },
    { "sym": 134, "bits": "11111111|11111111|010101", "hex": "3fffd5", "bit_len": 22 },
    { "sym": 135, "bits": "11111111|11111111|1011001", "hex": "7fffd9", "bit_len": 23 },
    { "sym": 136, "bits": "11111111|11111111|010110", "hex": "3fffd6", "bit_len": 22 },
    { "sym": 137, "bits": "11111111|11111111|1011010", "hex": "7fffda", "bit_len": 23 },
    { "sym": 138, "bits": "11111111|11111111|1011011", "hex": "7fffdb", "bit_len": 23 },
    { "sym": 139, "bits": "11111111|11111111|1011100", "hex": "7fffdc", "bit_len": 23 },
    { "sym": 140, "bits": "11111111|11111111|1011101", "hex": "7fffdd", "bit_len": 23 },
    { "sym": 141, "bits": "11111111|11111111|1011110", "hex": "7fffde", "bit_len": 23 },
    { "sym": 142, "bits": "11111111|11111111|11101011", "hex": "ffffeb", "bit_len": 24 },
    { "sym": 143, "bits": "11111111|11111111|1011111", "hex": "7fffdf", "bit_len": 23 },
    { "sym": 144, "bits": "11111111|11111111|11101100", "hex": "ffffec", "bit_len": 24 },
    { "sym": 145, "bits": "11111111|11111111|11101101", "hex": "ffffed", "bit_len": 24 },
    { "sym": 146, "bits": "11111111|11111111|010111", "hex": "3fffd7", "bit_len": 22 },
    { "sym": 147, "bits": "11111111|11111111|1100000", "hex": "7fffe0", "bit_len": 23 },
    { "sym": 148, "bits": "11111111|11111111|11101110", "hex": "ffffee", "bit_len": 24 },
    { "sym": 149, "bits": "11111111|11111111|1100001", "hex": "7fffe1", "bit_len": 23 },
    { "sym": 150, "bits": "11111111|11111111|1100010", "hex": "7fffe2", "bit_len": 23 },
    { "sym": 151, "bits": "11111111|11111111|1100011", "hex": "7fffe3", "bit_len": 23 },
    { "sym": 152, "bits": "11111111|11111111|1100100", "hex": "7fffe4", "bit_len": 23 },
    { "sym": 153, "bits": "11111111|11111110|11100", "hex": "1fffdc", "bit_len": 21 },
    { "sym": 154, "bits": "11111111|11111111|011000", "hex": "3fffd8", "bit_len": 22 },
    { "sym": 155, "bits": "11111111|11111111|1100101", "hex": "7fffe5", "bit_len": 23 },
    { "sym": 156, "bits": "11111111|11111111|011001", "hex": "3fffd9", "bit_len": 22 },
    { "sym": 157, "bits": "11111111|11111111|1100110", "hex": "7fffe6", "bit_len": 23 },
    { "sym": 158, "bits": "11111111|11111111|1100111", "hex": "7fffe7", "bit_len": 23 },
    { "sym": 159, "bits": "11111111|11111111|11101111", "hex": "ffffef", "bit_len": 24 },
    { "sym": 160, "bits": "11111111|11111111|011010", "hex": "3fffda", "bit_len": 22 },
    { "sym": 161, "bits": "11111111|11111110|11101", "hex": "1fffdd", "bit_len": 21 },
    { "sym": 162, "bits": "11111111|11111110|1001", "hex": "fffe9", "bit_len": 20 },
    { "sym": 163, "bits": "11111111|11111111|011011", "hex": "3fffdb", "bit_len": 22 },
    { "sym": 164, "bits": "11111111|11111111|011100", "hex": "3fffdc", "bit_len": 22 },
    { "sym": 165, "bits": "11111111|11111111|1101000", "hex": "7fffe8", "bit_len": 23 },
    { "sym": 166, "bits": "11111111|11111111|1101001", "hex": "7fffe9", "bit_len": 23 },
    { "sym": 167, "bits": "11111111|11111110|11110", "hex": "1fffde", "bit_len": 21 },
    { "sym": 168, "bits": "11111111|11111111|1101010", "hex": "7fffea", "bit_len": 23 },
    { "sym": 169, "bits": "11111111|11111111|011101", "hex": "3fffdd", "bit_len": 22 },
    { "sym": 170, "bits": "11111111|11111111|011110", "hex": "3fffde", "bit_len": 22 },
    { "sym": 171, "bits": "11111111|11111111|11110000", "hex": "fffff0", "bit_len": 24 },
    { "sym": 172, "bits": "11111111|11111110|11111", "hex": "1fffdf", "bit_len": 21 },
    { "sym": 173, "bits": "11111111|11111111|011111", "hex": "3fffdf", "bit_len": 22 },
    { "sym": 174, "bits": "11111111|11111111|1101011", "hex": "7fffeb", "bit_len": 23 },
    { "sym": 175, "bits": "11111111|11111111|1101100", "hex": "7fffec", "bit_len": 23 },
    { "sym": 176, "bits": "11111111|11111111|00000", "hex": "1fffe0", "bit_len": 21 },
    { "sym": 177, "bits": "11111111|11111111|00001", "hex": "1fffe1", "bit_len": 21 },
    { "sym": 178, "bits": "11111111|11111111|100000", "hex": "3fffe0", "bit_len": 22 },
    { "sym": 179, "bits": "11111111|11111111|00010", "hex": "1fffe2", "bit_len": 21 },
    { "sym": 180, "bits": "11111111|11111111|1101101", "hex": "7fffed", "bit_len": 23 },
    { "sym": 181, "bits": "11111111|11111111|100001", "hex": "3fffe1", "bit_len": 22 },
    { "sym": 182, "bits": "11111111|11111111|1101110", "hex": "7fffee", "bit_len": 23 },
    { "sym": 183, "bits": "11111111|11111111|1101111", "hex": "7fffef", "bit_len": 23 },
    { "sym": 184, "bits": "11111111|11111110|1010", "hex": "fffea", "bit_len": 20 },
    { "sym": 185, "bits": "11111111|11111111|100010", "hex": "3fffe2", "bit_len": 22 },
    { "sym": 186, "bits": "11111111|11111111|100011", "hex": "3fffe3", "bit_len": 22 },
    { "sym": 187, "bits": "11111111|11111111|100100", "hex": "3fffe4", "bit_len": 22 },
    { "sym": 188, "bits": "11111111|11111111|1110000", "hex": "7ffff0", "bit_len": 23 },
    { "sym": 189, "bits": "11111111|11111111|100101", "hex": "3fffe5", "bit_len": 22 },
    { "sym": 190, "bits": "11111111|11111111|100110", "hex": "3fffe6", "bit_len": 22 },
    { "sym": 191, "bits": "11111111|11111111|1110001", "hex": "7ffff1", "bit_len": 23 },
    { "sym": 192, "bits": "11111111|11111111|11111000|00", "hex": "3ffffe0", "bit_len": 26 },
    { "sym": 193, "bits": "11111111|11111111|11111000|01", "hex": "3ffffe1", "bit_len": 26 },
    { "sym": 194, "bits": "11111111|11111110|1011", "hex": "fffeb", "bit_len": 20 },
    { "sym": 195, "bits": "11111111|11111110|001", "hex": "7fff1", "bit_len": 19 },
    { "sym": 196, "bits": "11111111|11111111|100111", "hex": "3fffe7", "bit_len": 22 },
    { "sym": 197, "bits": "11111111|11111111|1110010", "hex": "7ffff2", "bit_len": 23 },
    { "sym": 198, "bits": "11111111|11111111|101000", "hex": "3fffe8", "bit_len": 22 },
    { "sym": 199, "bits": "11111111|11111111|11110110|0", "hex": "1ffffec", "bit_len": 25 },
    { "sym": 200, "bits": "11111111|11111111|11111000|10", "hex": "3ffffe2", "bit_len": 26 },
    { "sym": 201, "bits": "11111111|11111111|11111000|11", "hex": "3ffffe3", "bit_len": 26 },
    { "sym": 202, "bits": "11111111|11111111|11111001|00", "hex": "3ffffe4", "bit_len": 26 },
    { "sym": 203, "bits": "11111111|11111111|11111011|110", "hex": "7ffffde", "bit_len": 27 },
    { "sym": 204, "bits": "11111111|11111111|11111011|111", "hex": "7ffffdf", "bit_len": 27 },
    { "sym": 205, "bits": "11111111|11111111|11111001|01", "hex": "3ffffe5", "bit_len": 26 },
    { "sym": 206, "bits": "11111111|11111111|11110001", "hex": "fffff1", "bit_len": 24 },
    { "sym": 207, "bits": "11111111|11111111|11110110|1", "hex": "1ffffed", "bit_len": 25 },
    { "sym": 208, "bits": "11111111|11111110|010", "hex": "7fff2", "bit_len": 19 },
    { "sym": 209, "bits": "11111111|11111111|00011", "hex": "1fffe3", "bit_len": 21 },
    { "sym": 210, "bits": "11111111|11111111|11111001|10", "hex": "3ffffe6", "bit_len": 26 },
    { "sym": 211, "bits": "11111111|11111111|11111100|000", "hex": "7ffffe0", "bit_len": 27 },
    { "sym": 212, "bits": "11111111|11111111|11111100|001", "hex": "7ffffe1", "bit_len": 27 },
    { "sym": 213, "bits": "11111111|11111111|11111001|11", "hex": "3ffffe7", "bit_len": 26 },
    { "sym": 214, "bits": "11111111|11111111|11111100|010", "hex": "7ffffe2", "bit_len": 27 },
    { "sym": 215, "bits": "11111111|11111111|11110010", "hex": "fffff2", "bit_len": 24 },
    { "sym": 216, "bits": "11111111|11111111|00100", "hex": "1fffe4", "bit_len": 21 },
    { "sym": 217, "bits": "11111111|11111111|00101", "hex": "1fffe5", "bit_len": 21 },
    { "sym": 218, "bits": "11111111|11111111|11111010|00", "hex": "3ffffe8", "bit_len": 26 },
    { "sym": 219, "bits": "11111111|11111111|11111010|01", "hex": "3ffffe9", "bit_len": 26 },
    { "sym": 220, "bits": "11111111|11111111|11111111|1101", "hex": "ffffffd", "bit_len": 28 },
    { "sym": 221, "bits": "11111111|11111111|11111100|011", "hex": "7ffffe3", "bit_len": 27 },
    { "sym": 222, "bits": "11111111|11111111|11111100|100", "hex": "7ffffe4", "bit_len": 27 },
    { "sym": 223, "bits": "11111111|11111111|11111100|101", "hex": "7ffffe5", "bit_len": 27 },
    { "sym": 224, "bits": "11111111|11111110|1100", "hex": "fffec", "bit_len": 20 },
    { "sym": 225, "bits": "11111111|11111111|11110011", "hex": "fffff3", "bit_len": 24 },
    { "sym": 226, "bits": "11111111|11111110|1101", "hex": "fffed", "bit_len": 20 },
    { "sym": 227, "bits": "11111111|11111111|00110", "hex": "1fffe6", "bit_len": 21 },
    { "sym": 228, "bits": "11111111|11111111|101001", "hex": "3fffe9", "bit_len": 22 },
    { "sym": 229, "bits": "11111111|11111111|00111", "hex": "1fffe7", "bit_len": 21 },
    { "sym": 230, "bits": "11111111|11111111|01000", "hex": "1fffe8", "bit_len": 21 },
    { "sym": 231, "bits": "11111111|11111111|1110011", "hex": "7ffff3", "bit_len": 23 },
    { "sym": 232, "bits": "11111111|11111111|101010", "hex": "3fffea", "bit_len": 22 },
    { "sym": 233, "bits": "11111111|11111111|101011", "hex": "3fffeb", "bit_len": 22 },
    { "sym": 234, "bits": "11111111|11111111|11110111|0", "hex": "1ffffee", "bit_len": 25 },
    { "sym": 235, "bits": "11111111|11111111|11110111|1", "hex": "1ffffef", "bit_len": 25 },
    { "sym": 236, "bits": "11111111|11111111|11110100", "hex": "fffff4", "bit_len": 24 },
    { "sym": 237, "bits": "11111111|11111111|11110101", "hex": "fffff5", "bit_len": 24 },
    { "sym": 238, "bits": "11111111|11111111|11111010|10", "hex": "3ffffea", "bit_len": 26 },
    { "sym": 239, "bits": "11111111|11111111|1110100", "hex": "7ffff4", "bit_len": 23 },
    { "sym": 240, "bits": "11111111|11111111|11111010|11", "hex": "3ffffeb", "bit_len": 26 },
    { "sym": 241, "bits": "11111111|11111111|11111100|110", "hex": "7ffffe6", "bit_len": 27 },
    { "sym": 242, "bits": "11111111|11111111|11111011|00", "hex": "3ffffec", "bit_len": 26 },
    { "sym": 243, "bits": "11111111|11111111|11111011|01", "hex": "3ffffed", "bit_len": 26 },
    { "sym": 244, "bits": "11111111|11111111|11111100|111", "hex": "7ffffe7", "bit_len": 27 },
    { "sym": 245, "bits": "11111111|11111111|11111101|000", "hex": "7ffffe8", "bit_len": 27 },
    { "sym": 246, "bits": "11111111|11111111|11111101|001", "hex": "7ffffe9", "bit_len": 27 },
    { "sym": 247, "bits": "11111111|11111111|11111101|010", "hex": "7ffffea", "bit_len": 27 },
    { "sym": 248, "bits": "11111111|11111111|11111101|011", "hex": "7ffffeb", "bit_len": 27 },
    { "sym": 249, "bits": "11111111|11111111|11111111|1110", "hex": "ffffffe", "bit_len": 28 },
    { "sym": 250, "bits": "11111111|11111111|11111101|100", "hex": "7ffffec", "bit_len": 27 },
    { "sym": 251, "bits": "11111111|11111111|11111101|101", "hex": "7ffffed", "bit_len": 27 },
    { "sym": 252, "bits": "11111111|11111111|11111101|110", "hex": "7ffffee", "bit_len": 27 },
    { "sym": 253, "bits": "11111111|11111111|11111101|111", "hex": "7ffffef", "bit_len": 27 },
    { "sym": 254, "bits": "11111111|11111111|11111110|000", "hex": "7fffff0", "bit_len": 27 },
    { "sym": 255, "bits": "11111111|11111111|11111011|10", "hex": "3ffffee", "bit_len": 26 },
    { "sym": 256, "bits": "11111111|11111111|11111111|111111", "hex": "3fffffff", "bit_len": 30 },
]

class BitArray {
    private _size: number
    private bytes: Uint8ClampedArray

    constructor(size: number) {
        this._size = size;
        this.bytes = new Uint8ClampedArray(Math.ceil(size / 8));
    }

    set(index: number, value: boolean): void {
        if (index >= this._size || index < 0) {
            throw new Error("Out of bounds set")
        }

        const byteIndex = index >> 3;
        const bitIndex = 7 - (index & 7);

        if (value) {
            this.bytes[byteIndex]! |= (1 << bitIndex);
        } else {
            this.bytes[byteIndex]! &= ~(1 << bitIndex);
        }
    }

    get(index: number): boolean {
        if (index >= this._size || index < 0) {
            throw new Error("Out of bounds get")
        }

        const byteIndex = index >> 3;
        const bitIndex = 7 - (index & 7);


        return ((this.bytes[byteIndex]! >> bitIndex) & 0x1) != 0;
    }

    get size(): number {
        return this._size;
    }

    toNumberArray(): number[] {

        return Array.from(this.bytes)
    }
}


function test_bitarray() {

    const values: [number, number, number[]][] = [[0b10101011, 8, [0b10101011]], [0xFF, 8, [0xFF]], [0xA8, 8, [0xA8]], [0x56F1, 16, [0x56, 0xF1]]]


    for (const [value, value_sz, value_arr] of values) {

        const temp = new BitArray(value_sz)

        for (let i = 0; i < value_sz; ++i) {

            const val = ((value >> (value_sz - i - 1)) & 0x1) != 0;

            temp.set(i, val)
        }

        const temp_res = temp.toNumberArray();

        if (!num_array_is_eq(temp_res, value_arr)) {
            throw new Error(`The bitarray doesn't work as expected: ${temp_res} - ${value_arr}`)
        }

    }

}

function get_bit_array_from_bits(bits: string, bit_len: number, hex_value: string): BitArray {

    const values = bits.split("|")

    if (values.length == 0) {
        throw new Error("not a valid bits string")
    }

    const size = (values.length - 1) * 8 + values.at(-1)!.length;

    if (bit_len != size) {
        throw new Error("not a valid bits string")
    }

    const hex_b = BigInt(`0x${hex_value}`)

    const hex_b2 = BigInt(`0b${values.join("")}`)

    if (hex_b != hex_b2) {
        throw new Error(`not a valid bits string: ${hex_b} != ${hex_b2}`)
    }

    const result = new BitArray(size)

    for (let i = 0; i < values.length; ++i) {
        const value = values[i]!
        if (i != values.length - 1) {
            if (value.length != 8) {
                throw new Error("not a valid bits string")
            }
        }

        for (let j = 0; j < value.length; ++j) {

            const bitStr = value[j]

            const index = i * 8 + j;

            if (bitStr == "0") {
                result.set(index, false)
            } else if (bitStr == "1") {
                result.set(index, true)
            } else {
                throw new Error("not a valid bits string")
            }


        }

    }



    return result;

}

interface HuffmanCodeBase {
    bytes: BitArray,
}

interface HuffmanCodeNormal extends HuffmanCodeBase {
    type: "normal"
    value: bigint,
}

type SpecialType = "EOS"

interface HuffmanCodeSpecial extends HuffmanCodeBase {
    type: "special"
    special: SpecialType
}


type HuffmanCode = HuffmanCodeNormal | HuffmanCodeSpecial

function check_and_map_raw_code(code: RawHuffmanCode): HuffmanCode {

    const bytes: BitArray = get_bit_array_from_bits(code.bits, code.bit_len, code.hex);

    if (!Number.isInteger(code.sym)) {
        throw new Error("invalid raw huffman code, not an integer")
    }

    if (code.sym < 0) {
        throw new Error("invalid raw huffman code")
    }

    if (code.sym > 255) {
        if (code.sym == 256) {
            const result: HuffmanCodeSpecial = { "bytes": bytes, type: "special", special: "EOS" }
            return result;
        }

        throw new Error("invalid raw huffman code")
    }

    const result: HuffmanCodeNormal = { "bytes": bytes, type: "normal", value: BigInt(code.sym) }


    return result


}

interface HuffManNodeNodeNode {
    bit_0: HuffManNode;
    bit_1: HuffManNode;
}

class HuffManNodeBasic {
    id: null | bigint

    constructor(id: null | bigint) {
        this.id = id;
    }
}

class HuffManNodeNode extends HuffManNodeBasic {
    type: "node"
    node: HuffManNodeNodeNode;

    constructor(node: HuffManNodeNodeNode | null) {
        super(null);

        this.type = "node";
        this.node = node === null ? { bit_0: new HuffManNodeEnd(null), bit_1: new HuffManNodeEnd(null) } : node;
    }
}

type EndValue = bigint | "EOS"

class HuffManNodeEnd extends HuffManNodeBasic {
    type: "end"
    value: EndValue | null

    constructor(value: EndValue | null) {
        super(null);

        this.type = "end";
        this.value = value
    }
}

type HuffManNode = HuffManNodeNode | HuffManNodeEnd

interface HuffmanTree {
    root: HuffManNode;
}

function getValue(code: HuffmanCode): EndValue {
    if (code.type === "normal") {
        return code.value
    }

    if (code.special === "EOS") {
        return "EOS"
    }

    throw new Error("Error")
}

function check_valid_root(root: HuffManNode): void {

    if (root.id === null) {
        throw new Error("NULL id on node")
    }

    if (root.type === "end") {
        if (root.value === null) {
            throw new Error("NULL end node")
        }
        return;
    }

    const node = root.node

    check_valid_root(node.bit_0)
    check_valid_root(node.bit_1)

}

interface TreeResult {
    tree: HuffmanTree
    node_amount: bigint
}

function codes_to_tree(codes: HuffmanCode[]): TreeResult {

    const root: HuffManNode = new HuffManNodeNode(null)

    for (const code of codes) {
        let currentNode: HuffManNode = root

        for (let i = 0; i < code.bytes.size; ++i) {
            const bit = code.bytes.get(i);

            const final = i == code.bytes.size - 1;

            if (final) {
                if (currentNode.type != "node") {
                    console.error(currentNode)
                    throw new Error("Error")
                }

                if (bit) {
                    if (currentNode.node.bit_1 === null) {
                        currentNode.node.bit_1 = new HuffManNodeEnd(getValue(code))
                    } else if (currentNode.node.bit_1.type == "end") {
                        if (currentNode.node.bit_1.value != null) {
                            console.error(currentNode.node.bit_1)
                            throw new Error("Error")
                        }

                        currentNode.node.bit_1 = new HuffManNodeEnd(getValue(code))
                    }
                } else {
                    if (currentNode.node.bit_0 === null) {
                        currentNode.node.bit_0 = new HuffManNodeEnd(getValue(code))
                    } else if (currentNode.node.bit_0.type == "end") {
                        if (currentNode.node.bit_0.value != null) {
                            console.error(currentNode.node.bit_0)
                            console.log(code)
                            throw new Error("Error")
                        }

                        currentNode.node.bit_0 = new HuffManNodeEnd(getValue(code))
                    }
                }

            } else {

                if (currentNode.type != "node") {
                    console.error(currentNode)
                    throw new Error("Error")

                }

                if (bit) {
                    if (currentNode.node.bit_1 === null) {
                        currentNode.node.bit_1 = new HuffManNodeNode(null)
                    } else if (currentNode.node.bit_1.type == "end") {
                        if (currentNode.node.bit_1.value != null) {
                            console.error(currentNode.node.bit_1)
                            throw new Error("Error")
                        }

                        currentNode.node.bit_1 = new HuffManNodeNode(null)
                    }

                    currentNode = currentNode.node.bit_1;
                } else {
                    if (currentNode.node.bit_0 === null) {
                        currentNode.node.bit_0 = new HuffManNodeNode(null)
                    } else if (currentNode.node.bit_0.type == "end") {
                        if (currentNode.node.bit_0.value != null) {
                            console.error(currentNode.node.bit_0)
                            throw new Error("Error")
                        }

                        currentNode.node.bit_0 = new HuffManNodeNode(null)
                    }

                    currentNode = currentNode.node.bit_0;
                }



            }



        }


    }

    const nodes: HuffManNode[] = [root]

    let id: bigint = 0n;

    // make an id for each node
    while (nodes.length != 0) {

        const node = nodes.pop()!;

        node.id = id;
        ++id;

        if (node.type != "end") {
            nodes.push(node.node.bit_0)
            nodes.push(node.node.bit_1)
        }

    }

    check_valid_root(root)

    const tree: HuffmanTree = { root: root }

    return { tree, node_amount: id };

}

type HuffmanEncodingMap = Record<string, HuffmanCodeNormal | undefined>;

function codes_to_map(codes: HuffmanCode[]): HuffmanEncodingMap {

    const map: HuffmanEncodingMap = {}


    for (const code of codes) {

        if (code.type == "special") {
            continue;
        }

        const index = Number(code.value);

        if (map[index] !== undefined) {
            throw new Error("duplicate symbol")
        }
        map[index] = code;

    }

    return map

}


function to_c_node(node: HuffManNode, nodes_array_value: string): string {

    if (node.type == "end") {

        if (node.value === "EOS") {

            return `
            ((HuffManNode){ .type = HuffManNodeTypeError, .data = { .error = "EOS received" } })`


        }

        if (node.value === null) {
            throw new Error("invalid node value")
        }

        if (node.value < 0 || node.value > 255) {
            throw new Error("invalid node value")
        }

        return `
            ((HuffManNode){ .type = HuffManNodeTypeEnd, .data = { .end = ${node.value.toString()} } })`

    }


    return `
            ((HuffManNode){ .type = HuffManNodeTypeNode, .data = { .node = (HuffManNodeNode){ .bit_0 = (${nodes_array_value} + ${node.node.bit_0.id}), .bit_1 = (${nodes_array_value} + ${node.node.bit_1.id}) } } })`


}

function writeFileAndDirs(file: string, content: string): void {

    const dir = path.dirname(file)

    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true })
    }

    fs.writeFileSync(file, content)


}


function tree_to_nodes(tree: HuffmanTree, node_amount: bigint, nodes_array_value: string): string[] {

    const values: string[] = new Array(Number(node_amount)).fill(undefined);

    function set_array_at(index: bigint | null, value: string) {

        if (index === null) {
            throw new Error("Invalid value")
        }

        if (index < 0) {
            throw new Error("Out of bounds")
        }

        if (index >= node_amount) {
            throw new Error("Out of bounds")
        }

        values[Number(index)] = value

    }

    const nodes: HuffManNode[] = [tree.root]

    // traverse all nodes
    while (nodes.length != 0) {

        const node = nodes.pop()!;

        set_array_at(node.id, to_c_node(node, nodes_array_value));

        if (node.type != "end") {
            nodes.push(node.node.bit_0)
            nodes.push(node.node.bit_1)
        }

    }

    return values;

}

function generated_hpack_code_c(generated_hpack_file: string, tree_result: TreeResult): void {

    const { node_amount, tree } = tree_result

    const nodes_array_value = "nodes_array"

    const nodes: string[] = tree_to_nodes(tree, node_amount, nodes_array_value)


    const c_data = `
#include "http/hpack_huffman.h"

#define HUFFMAN_NODE_AMOUNT ${node_amount.toString()}

NODISCARD HuffManTree* get_hpack_huffman_tree(void) {

\tHuffManTree* tree = malloc(sizeof(HuffManTree));

\tif(tree == NULL) {
\t\treturn NULL;
\t}

\tHuffManNode* ${nodes_array_value} = malloc(sizeof(HuffManNode) * HUFFMAN_NODE_AMOUNT);

\tif(${nodes_array_value} == NULL) {
\t\tfree(tree);
\t\treturn NULL;
\t}

\t{
\t
${nodes.map((val, i) => {

        return `\t${nodes_array_value}[${i}] = ${val};`;
    }).join("\n")}

\t}

\tHuffManNode* root = (${nodes_array_value} + ${tree.root.id});

\t*tree = (HuffManTree){ .root = root, .memory = (void*)${nodes_array_value} };

\treturn tree;
}

void free_hpack_huffman_tree(HuffManTree* tree) {
\tfree(tree->memory);
\tfree(tree);
}
`

    writeFileAndDirs(generated_hpack_file, c_data)


}

interface EncodedHuffmanValues {
    bytes: BitArray,
}

class EncodedHuffman {
    private values: EncodedHuffmanValues[]

    constructor(values: EncodedHuffmanValues[]) {
        this.values = values
    }

    toArray(): BitArray {

        let size: number = 0;

        for (const value of this.values) {
            size += value.bytes.size;
        }

        if (size % 8 != 0) {
            size += 8 - (size % 8);
        }

        console.assert((size % 8) == 0, "implementation error")

        const result = new BitArray(size);

        let index = 0;

        for (const value of this.values) {

            const b_size = value.bytes.size;
            for (let i = 0; i < b_size; ++i) [
                result.set(index + i, value.bytes.get(i))
            ]

            index += b_size;
        }

        // set EOS bits
        for (let i = index; i < size; ++i) [
            result.set(i, true)
        ]


        return result
    }

    toNumArray(): number[] {

        const arr = this.toArray()

        if (arr.size % 8 != 0) {
            console.error(arr.size, arr.size % 8)
            throw new Error("Encoding error")
        }

        const array = arr.toNumberArray()


        return array;

    }

}

interface EncodedHuffmanAscii {
    type: "ascii",
    value: string,
    encoded: EncodedHuffman
}

interface EncodedHuffmanUtf8 {
    type: "utf-8",
    value: Uint8Array<ArrayBuffer>,
    encoded: EncodedHuffman
}

type EncodedHuffmanGeneric = EncodedHuffmanAscii | EncodedHuffmanUtf8


function encode_normal_string_with_huffman(map: HuffmanEncodingMap, text: string): EncodedHuffmanAscii {

    const values: EncodedHuffmanValues[] = []

    for (const char of text) {

        if (char.length != 1) {
            throw new Error("Invalid decoding, use TextEncoder to encode it in bytes and not utf8");
        }

        const charValue = char.charCodeAt(0)

        const value = map[charValue]

        if (value === undefined) {
            console.error(charValue)
            throw new Error("Invalid decoding, use TextEncoder to encode it in bytes and not utf8");
        }

        const val: EncodedHuffmanValues = { bytes: value.bytes }

        values.push(val)
    }

    const result: EncodedHuffmanAscii = { type: "ascii", value: text, encoded: new EncodedHuffman(values) }

    return result;
}

function is_utf8_string(text: string): boolean {

    const array = new TextEncoder().encode(text)

    return array.length != text.length;
}

function encode_uft8_string_with_huffman(map: HuffmanEncodingMap, text: string): EncodedHuffmanUtf8 {

    const array = new TextEncoder().encode(text)

    const values: EncodedHuffmanValues[] = []

    for (const char of array) {
        const value = map[char]

        if (value === undefined) {
            console.error(char)
            throw new Error("Implementation error, or the number was out of bound of a char");
        }

        const val: EncodedHuffmanValues = { bytes: value.bytes }

        values.push(val)

    }

    const result: EncodedHuffmanUtf8 = { type: "utf-8", value: array, encoded: new EncodedHuffman(values) }

    return result;
}

function encode_string_with_huffman(map: HuffmanEncodingMap, text: string): EncodedHuffmanGeneric {

    if (!is_utf8_string(text)) {
        return encode_normal_string_with_huffman(map, text);
    }

    return encode_uft8_string_with_huffman(map, text)
}


function toHexString(num: number): string {

    return `0x${num.toString(16).padStart(2, "0")}`
}

function normal_test_to_cpp(caze: EncodedHuffmanAscii): string {

    const arr: number[] = caze.encoded.toNumArray();

    return `\t\TestCaseAscii{ .str = std::string{"${caze.value}"}, .encoded = std::vector<std::uint8_t>{ ${arr.map((a) => toHexString(a)).join(", ")}} }`

}


function normal_tests_to_cpp(cases: EncodedHuffmanGeneric[]): string[] {
    return cases.filter(a => {
        return (a.type === "ascii")
    }).map(a => normal_test_to_cpp(a))
}

function utf8_test_to_cpp(caze: EncodedHuffmanUtf8): string {

    const arr: number[] = caze.encoded.toNumArray();

    return `\t\tTestCaseUtf8{ .value = std::vector<std::uint8_t>{${Array.from(caze.value).map((a) => toHexString(a)).join(", ")}}, .encoded =  std::vector<std::uint8_t>{ ${arr.map((a) => toHexString(a)).join(", ")}} }`

}


function utf8_tests_to_cpp(cases: EncodedHuffmanGeneric[]): string[] {
    return cases.filter(a => {
        return (a.type === "utf-8")
    }).map(a => utf8_test_to_cpp(a))
}

type ManualTest = [number, number]

function get_manual_test_arr(manual_test_arr: ManualTest[]): number[] {

    let size = 0;


    for (const man of manual_test_arr) {
        size += man[1]
    }


    if (size % 8 != 0) {
        size += 8 - (size % 8);
    }

    console.assert((size % 8) == 0, "implementation error")

    const result = new BitArray(size);


    let offset = 0;

    for (const man of manual_test_arr) {

        const local_size = man[1];

        for (let i = 0; i < local_size; ++i) {

            const value = ((man[0] >> (local_size - 1 - i)) & 0x1) != 0;

            result.set(offset + i, value)

        }


        offset += local_size
    }


    // set EOS bits
    for (let i = offset; i < size; ++i) [
        result.set(i, true)
    ]


    return result.toNumberArray();

}

function num_array_is_eq(arr1: number[], arr2: number[]): boolean {

    if (arr1.length != arr2.length) {
        return false;
    }

    for (let i = 0; i < arr1.length; ++i) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }


    return true;

}

function generated_hpack_test_cases_cpp(generated_hpack_test_cases_file: string, map: HuffmanEncodingMap): void {

    { // test js encoding
        const test_test_result = encode_normal_string_with_huffman(map, "307");

        const test_test_arr = test_test_result.encoded.toNumArray()

        // from the hpack spec examples
        const test_test_arr_expected = [0x64, 0x0e, 0xff]

        // manually constructed for "307"
        const test_test_arr_manual = get_manual_test_arr([[0b011001, 6], [0b00000, 5], [0b011101, 6]])

        if (!num_array_is_eq(test_test_arr_manual, test_test_arr_expected)) {
            throw new Error(`The manual encoding is not done correctly, as the manual and the expected array differ: ${test_test_arr_manual} - ${test_test_arr_expected}`)
        }

        if (!num_array_is_eq(test_test_arr, test_test_arr_expected)) {
            throw new Error(`The js encoding is not done correctly, as the js encoded and the expected array differ: ${test_test_arr} - ${test_test_arr_expected}`)
        }

    }



    { // test utf8 detection

        console.assert(is_utf8_string("UTF-8:  "), "utf-8 string detected correctly")


    }

    const test_cases: string[] = [
        "www.example.com",
        "no-cache",
        "custom-key",
        "custom-value",
        "307",
        "hello world",
        "sadsafipefbsafpidsbafabhfkjagfka",
        "my test",
        "somespecial-things1212*#*!!!##$%&/()[]{}",
        "mreallylongtextthat goes on and on, on and on, like this",
        "aeiaeiaeiaeiaeiaei", // really short encoding
        "012012012012012", // really short encoding
        "UTF-8:  ", // utf8
        "UTF-8: `e ",// utf8
        "UTF-8:    ",// utf8
        "UTF-8:  `e    ",// utf8
    ]

    const final_test_case: EncodedHuffmanGeneric[] = test_cases.map((original) => {
        const encoded = encode_string_with_huffman(map, original)
        return encoded;
    });

    const cpp_data = `
#pragma once

#include <cstdint>
#include <string>
#include <vector>

namespace generated::tests {

\tstruct TestCaseAscii {
\t\tstd::string str;
\t\tstd::vector<std::uint8_t> encoded;
\t};

\tstruct TestCaseUtf8 {
\t\tstd::vector<std::uint8_t> value;
\t\tstd::vector<std::uint8_t> encoded;
\t};

\tconst std::vector<TestCaseAscii> test_cases_ascii = {
${normal_tests_to_cpp(final_test_case).join(",\n")}
\t}; 

\tconst std::vector<TestCaseUtf8> test_cases_utf8 = {
${utf8_tests_to_cpp(final_test_case).join(",\n")}
\t}; 

} // namespace generated::tests
`

    writeFileAndDirs(generated_hpack_test_cases_file, cpp_data)

}



function generateFile(options: GenerateOptions): void {

    test_bitarray();

    const codes: HuffmanCode[] = raw_codes.map(code => check_and_map_raw_code(code))

    if (options.type === "c") {
        const tree_result = codes_to_tree(codes)
        generated_hpack_code_c(options.output, tree_result)
        return;
    } else if (options.type === "cpp_tests") {
        const map = codes_to_map(codes)
        generated_hpack_test_cases_cpp(options.output, map)
        return;
    }

    throw new Error(`Unrecognized type: ${options.type}`)


}

type GenerateType = "cpp_tests" | "c"

interface GenerateOptions {
    output: string,
    type: GenerateType
}

function main(): void {
    const options: Partial<GenerateOptions> = {
    }

    for (let i = 0; i < process.argv.length; ++i) {
        const value = process.argv[i]!

        if (value.endsWith('node')) {
            continue
        }

        if (value.endsWith('.js')) {
            continue
        }

        if (value.endsWith('.ts')) {
            continue
        }

        if (value == '-o' || value == '--output') {
            if (i + 1 >= process.argv.length) {
                throw new Error(
                    `Expected another argument for the output argument`
                )
            }


            const output = path.resolve(process.argv[i + 1]!)

            options.output = output
            ++i
            continue
        }

        if (value == '-t' || value == '--type') {
            if (i + 1 >= process.argv.length) {
                throw new Error(
                    `Expected another argument for the type argument`
                )
            }

            const typeRaw = process.argv[i + 1]!

            if (typeRaw !== "c" && typeRaw !== "cpp_tests") {
                throw new Error(
                    `Invaldi type: ${typeRaw}`
                )
            }

            options.type = typeRaw

            ++i
            continue
        }

        if (value == '--ignore-after') {
            break
        }

        throw new Error(`Unrecognized argument: ${value}`)
    }

    if (!options.type) {
        throw new Error(`No type given`)
    }

    if (!options.output) {
        throw new Error(`No output given`)
    }

    generateFile(options as GenerateOptions)
}



main()
